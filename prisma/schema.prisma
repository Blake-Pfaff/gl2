
generator client {
  provider = "prisma-client-js"
}
datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

enum InteractionType {
  LIKE
  DISLIKE
  SUPERLIKE
}

enum Gender {
  WOMAN
  MAN
  NON_BINARY
  GENDERFLUID
  AGENDER
  TRANSGENDER_WOMAN
  TRANSGENDER_MAN
  QUESTIONING
  PREFER_NOT_TO_SAY
  OTHER
}

enum LookingFor {
  WOMEN
  MEN
  NON_BINARY_PEOPLE
  EVERYONE
}

model User {
  id              String     @id @default(cuid())
  email           String     @unique
  username        String?    @unique
  name            String?
  jobTitle        String?    // e.g., "Graphic Designer"
  bio             String?    // gallery for profile
  birthdate       DateTime?  // derive age in UI
  phone           String?    @unique
  gender          Gender?
  lookingFor      LookingFor?
  lastOnlineAt    DateTime?
  locationLabel   String?    // nice address text for UI
  hashedPassword  String? 
  createdAt       DateTime   @default(now())

  // User's photos
  photos         Photo[]

  // One-to-one optional location
  location       UserLocation?

  // Interactions: from this user (likes, dislikes, superlikes they've given)
  interactionsFrom Interaction[] @relation("interactions_from")

  // Interactions: to this user (likes, dislikes, superlikes they've received)
  interactionsTo   Interaction[] @relation("interactions_to")

  // Blocks: users this user has blocked
  blocksGiven      Block[]       @relation("blocks_given")

  // Blocks: users who have blocked this user
  blocksReceived   Block[]       @relation("blocks_received")

  // Matches where this user is the "A" side
  matchesA       Match[]    @relation("A")

  // Matches where this user is the "B" side
  matchesB       Match[]    @relation("B")
}

model UserLocation {
  userId    String @id
  latitude  Float
  longitude Float
  user      User   @relation(fields: [userId], references: [id])
}

model Interaction {
  fromId    String
  toId      String
  type      InteractionType
  createdAt DateTime @default(now())

  from      User     @relation("interactions_from", fields: [fromId], references: [id])
  to        User     @relation("interactions_to", fields: [toId], references: [id])

  @@id([fromId, toId])
  @@index([fromId])
  @@index([toId])
  @@index([type])
}

model Block {
  id        String   @id @default(cuid())
  blockerId String   // User who is doing the blocking
  blockedId String   // User who is being blocked
  reason    String?  // Optional reason for blocking
  createdAt DateTime @default(now())

  // Relationships
  blocker   User     @relation("blocks_given", fields: [blockerId], references: [id])
  blocked   User     @relation("blocks_received", fields: [blockedId], references: [id])

  @@unique([blockerId, blockedId])
  @@index([blockerId])
  @@index([blockedId])
}

model Match {
  id        String     @id @default(cuid())
  aId       String
  bId       String
  createdAt DateTime   @default(now())

  // Link to User A
  A         User       @relation("A", fields: [aId], references: [id])

  // Link to User B
  B         User       @relation("B", fields: [bId], references: [id])

  // Back-reference for messages in this match
  messages  Message[]  @relation("MatchMessages")

  @@unique([aId, bId])
}

model Message {
  id        String     @id @default(cuid())
  matchId   String
  senderId  String
  body      String
  createdAt DateTime   @default(now())

  // Which match this belongs to
  match     Match      @relation("MatchMessages", fields: [matchId], references: [id])
}

model Photo {
  id        String   @id @default(cuid())
  userId    String
  url       String   // URL or path to the photo file
  caption   String?  // Optional caption for the photo
  order     Int      @default(0) // For ordering photos in profile
  isMain    Boolean  @default(false) // Is this the main profile photo
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relationship to User
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([userId, order])
}
